## React Class Components

1. Create a simple React application by removing items and content from a project generated by the Create React App default template
- We can generate a React app using `create-react-app`
```
npx create-react-app my-app-name
```
- This command will generate a default application. We generally don't need a lot of the files that are created this way. Things we can remove/alter for our basic purposes include:
  - Remove all files in the `public` folder except for `index.html`
  - Alter `index.html` to just include a `div` tag in the body, with an id of `root`
  ```html
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="utf-8" />
      <title>React App</title>
    </head>
    <body>
      <div id="root"></div>
    </body>
  </html>
  ```
  - From the src folder, remove the following extra files:
    - `App.css`
    - `App.test.js`
    - `logo.svg`
    - `serviceWorker.js`
    - `setupTests.js`
  - Update the contents of `App.js` to the simplified code: 
  ```js
  // ./src/App.js
  import React from 'react';

  function App() {
    return (
      <h1>Hello world!</h1>
    );
  }

  export default App;
  ```
  - Update the contents of `index.js` to the simplified code:
  ```js
  // ./src/index.js
  import React from 'react';
  import ReactDOM from 'react-dom';
  import './index.css';
  import App from './App';

  ReactDOM.render(
    <React.StrictMode>
      <App />
    </React.StrictMode>,
    document.getElementById('root')
  );
  ```
  - Remove any default styles generated for you in `index.css`

2. Create a simple React application using a custom Create React App template
- Templates allow you to change what is generated by `create-react-app`, which can save you from having to make all of the adjustments each time we want to create a simple application.
- App Academy has created a template that does the changes suggested above for you automatically:
```
npx create-react-app my-app-name --template @appacademy/simple
```

3. Create a React component using ES2015 class syntax
- In order for us to make a class component, we need to extend `React.Component` in our class definition.
- If we have functionality that we want to implement in our constructor (such as setting a default state or binding functions), we need to first invoke `super(props)`, which will set up the default functionality of the class that we inherit from `React.Component`
- Lifecycle methods can be written in the body of the class and will be invoked at the appropriate time during the component's life
- We are required to have a `render` function in our class that returns the content of our component to be rendered in the browser. This function will be invoked whenever our component mounts, when its state is set, when it receives new props, or when its parent component rerenders.
```js
// Clock.js
import React from 'react';

class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      time: new Date()
    };
  }

  componentDidMount() {
    this.interval = setInterval(this.tick, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.interval);
  }

  tick = () => {
    this.setState({ time: new Date() });
  }

  render() {
    let hours = this.state.time.getHours();
    let minutes = this.state.time.getMinutes();
    let seconds = this.state.time.getSeconds();

    hours = (hours < 10) ? `0${hours}` : hours;
    minutes = (minutes < 10) ? `0${minutes}` : minutes;
    seconds = (seconds < 10) ? `0${seconds}` : seconds;

    return (
      <div>
        <h1>Clock</h1>
        <div className='clock'>
          <p>
            <span>
              Time:
            </span>
            <span>
              {hours}:{minutes}:{seconds} PDT
            </span>
          </p>
          <p>Date: {this.state.time.toDateString()}</p>
        </div>
      </div>
    );
  }
};

export default Clock;
```

4. Understand when it's appropriate to use a class component
- Class components are useful when we want to keep track of the state of the application or perform lifecycle methods.
- If interacting with the component should change some data, such as keeping track of a form's input, or altering values based on button clicks, we would want to keep track of the changing data in state.
- If we want to perform some action when a component mounts, updates, or unmounts, we want to use the lifecycle methods `componentDidMount`, `componentDidUpdate`, or `componentWillUnmount`, which are available to us in a class component.
  - Common use case for lifecycle methods would be if we want to fetch data from a database or other API after mounting

5. Initialize and update state within a class component
- To initialize state, we assign `this.state` to our object with default values in the constructor
```js
constructor(props) {
  super(props);
  this.state = {
    time: new Date()
  };
}
```
- Whenever we want to update our state, we have to invoke the `setState` method, passing in whatever keys/values we would like to update on state. This is important because the method is what tells React that we need to rerender. If we reassign the value of state directly instead of invoking this method, React will not trigger a rerender and our component won't change in our browser.
```js
tick = () => {
  this.setState({ time: new Date() });
}
```

6. Provide default values for a class component's props
- To provide a default value for props, we can assign the `defaultProps` key on the class before we export it.
- This is especially important if we are keying into values on props that we are expecting. If we don't have a prop the first time we render and try to key in to a property on an undefined value, our code will error out. Assigning default values ensures keying in to these nested values does not result in an error before those props can be passed in to us (perhaps from an asynchronous call to a database or other API)
```js
PetDetails.defaultProps = {
  pet: {
    PetType: {},
  },
};
```

7. Add event listeners to elements
- In our JSX, we can use the camelCased versions of event attributes to assign callbacks to be invoked for those events.
- In the following example, the function `handleSecondNum` will be invoked whenever a change in value is detected in the input, and `add` will be invoked whenever the button is clicked.
```js
<input onChange={this.handleSecondNum} value={num2} placeholder="Second number" />
<button onClick={this.add}>+</button>
```

8. Prevent event default behavior
- When an event is triggered, the a reference to the event is passed to the event handler. By capturing this argument and invoking `preventDefault()` on it, we can prevent the default behavior from occuring.
```js
handleSubmit = e => {
  e.preventDefault();
  // ... whatever code we would like our handler to invoke instead of the default form submission behavior
}
```

9. Safely use the `this` keyword within event handlers
- In order to preserve the context of `this` within an event handler, we can either define the function as a fat arrow function, or bind its context within the constructor.
- The reason we need to do one of these approaches is because the event handlers are invoked function style as callbacks, so `this` will be undefined in the browser.
```js
// fat arrow implementation
add = () => {
  const result = this.state.num1 + this.state.num2;
  this.setState({ result });
};

// bind approach
constructor(props){
  super(props);
  // ... other functionality, like setting up state
  this.add = this.add.bind(this);
}

add = function() {
  const result = this.state.num1 + this.state.num2;
  this.setState({ result });
};
```

10. Understand what the React `SyntheticEvent` object is and the role it plays in handling events
- React wraps events triggered in the browser in a class called `SyntheticEvent`
- All of the functionality of the event is preserved, but it provides a standard interface that React can interact with, which is important since different browsers may create event objects slightly differently.

11. Create a React class component containing a simple form
- Below you'll see a `ContactUs` component which uses a form so that a user can submit contact information (we'll expand on this with comments later).
- Notable parts of this component are that a change in the inputs triggers an event listener callback. We want to tie this change in to an update to our component's state, which we are linking to the value.
```js
// ./src/ContactUs.js

import React from 'react';

class ContactUs extends React.Component {
  constructor() {
    super();

    this.state = {
      name: '',
      email: '',
      phone: '',
    };
  }

  onChange = (e) => {
    const { name, value } = e.target;
    this.setState({ [name]: value });
  }

  onSubmit = (e) => {
    // Prevent the default form behavior
    // so the page doesn't reload.
    e.preventDefault();

    // Retrieve the contact us information from state.
    const { name, email, phone } = this.state; 

    // Create a new object for the contact us information.
    const contactUsInformation = {
      name,
      email,
      phone,
      submittedOn: new Date(),
    };

    // For now, just log the contact us information to the console
    // though ideally, we'd persist this information to a database
    // using a REST API.
    console.log(contactUsInformation);

    // Reset the form state.
    this.setState({
      name: '',
      email: '',
      phone: '',
    });
  }

  render() {
    const { name, email, phone } = this.state;

    return (
      <div>
        <h2>Contact Us</h2>
        <form onSubmit={this.onSubmit}>
          <div>
            <label htmlFor='name'>Name:</label>
            <input id='name' name='name' type='text' onChange={this.onChange} value={name} />
            {/* The onChange attribute is linked the the event listener this.onChange, which is triggered whenever we type in the input */}
            {/* The value for each input is linked to the state's key associated with this field */}
          </div>
          <div>
            <label htmlFor='email'>Email:</label>
            <input id='email' name='email' type='text' onChange={this.onChange} value={email} />
          </div>
          <div>
            <label htmlFor='phone'>Phone:</label>
            <input id='phone' name='phone' type='text' onChange={this.onChange} value={phone} />
          </div>
          <div>
            <button>Submit</button>
          </div>
        </form>
      </div>
    );
  }
}

export default ContactUs;
```

12. Define a single event handler method to handle `onChange` events for multiple <input> elements
- By utilizing the `name` attribute of our form's components, we can get a reference to which part of state we are trying to update from the event's target, just like how we are getting the value.
- In our call to setState, we use brackets around the name in order to evaluate the key, instead of creating/updating a key that is literally called `name`
```js
// event handler
onChange = (e) => {
  const { name, value } = e.target;
  this.setState({ [name]: value });
}

// in our form
// The div is being used to collect the label and input into one container for easier styling (there's no functional purpose to it) 
<div>
  <label htmlFor='phone'>Phone:</label>
  <input id='phone' name='phone' type='text' onChange={this.onChange} value={phone} />
</div>
```

13. Add a <textarea> element to a form
- Textareas are actually easier and more consistent to work with within React than their standard HTML counterparts.
- In HTML, the content of textareas are the values, the value is between the opening and closing tags.
- In React, we treat the value as an attribute just like our input tags, making our textarea a self-closing tag:
```js
<div>
  <label htmlFor='comments'>Comments:</label>
  <textarea id='comments' name='comments' onChange={this.onChange} value={comments} />
</div>
```
- In practice, this means we can treat `textarea` tags just like a regular `input` tag in React

14. Add a <select> element to a form
- In React, the value associated with our `select` reflects which option has been selected.
- In the following example, we map over many options for a `phoneType` and create a new `option` tag for each type.
- The `select` has many similarities to `input` in that we can assign an event listener to onChange, and a name and value so that our event handler can update the appropriate key in our state.
```js
<div>
  <label htmlFor='phone'>Phone:</label>
  <input id='phone' name='phone' type='text' onChange={this.onChange} value={phone} />
  <select name='phoneType' onChange={this.onChange} value={phoneType}>
    <option value=''>Select a phone type...</option>
    {
      this.props.phoneTypes.map(phoneType =>
        <option key={phoneType}>{phoneType}</option>
      )
    }
  </select>
</div>
```

15. Implement form validations
- In order to validate user input, we can track any validation errors related to the form as an array in our component's state.
- When we attempt to submit our form, we can run our validations and put any error messages that we want to display in an array.
- If the array has any content, we know that at least one of our validations failed. Instead of sending off our request to our server, we can set our component's state to include these error messages.
- In our render method, if our state has any errors to display, we can show them to the user directly within the component.
- Below is a simplified version of our `ContactUs` component, with validations for name and email.
```js
// Our custom validate functions checks that a name and email are both present. If not, it pushes a descriptive message into the array that it returns.
validate(name, email) {
  const validationErrors = [];

  if (!name) {
    validationErrors.push('Please provide a Name');
  }

  if (!email) {
    validationErrors.push('Please provide an Email');
  }
  
  return validationErrors;
}

// Our submit event handler invokes our validate function. If we had errors, it sets the state of our component with these errors. If we didn't it processes the submission like normal
onSubmit = (e) => {
  e.preventDefault();

  const { name, email } = this.state; 

  // Get validation errors.
  const validationErrors = this.validate(name, email);

  // If we have validation errors...
  if (validationErrors.length > 0) {
    // Update the state to display the validation errors.
    this.setState({ validationErrors });
  } else {
    // Create a new object for the contact us information.
    const contactUsInformation = {
      name,
      email,
    };

    // For now, just log the contact us information to the console
    // though ideally, we'd persist this information to a database
    // using a REST API.
    console.log(contactUsInformation);

    // Reset the form state.
    this.setState({
      name: '',
      email: '',
      validationErrors: [],
    });
  }
}

// Our render function checks to see if our validationErrors slice of state has any content (length > 0)
// If it does, the second part of the conditional is evaluated and returned, which displays a div that houses each error message
render() {
    const { name, email, validationErrors } = this.state;

    return (
      <div>
        <h2>Contact Us</h2>
        { validationErrors.length > 0 && (
            <div>
              The following errors were found:
              <ul>
                {validationErrors.map(error => <li key={error}>{error}</li>)}
              </ul>
            </div>
          )
        }
        <form onSubmit={this.onSubmit}>
          <div>
            <label htmlFor='name'>Name:</label>
            <input id='name' name='name' type='text' onChange={this.onChange} value={name} />
          </div>
          <div>
            <label htmlFor='email'>Email:</label>
            <input id='email' name='email' type='text' onChange={this.onChange} value={email} />
          </div>
          <div>
            <button>Submit</button>
          </div>
        </form>
      </div>
    );
  }
}
```

16. Understand the lifecycle of a React component
- When we render a React component, we follow a specific order of events
  1. Our constructor function is invoked
  2. We render our component
  3. Our `componentDidMount` method is invoked
  4. If we receive any new props, our state changes by invoking `setState`, or our parent rerenders, our `render` function is invoked, then `componentDidUpdate` (which itself could trigger any of these events and another rerender)
  5. Before our component is taken off of the page, our `componentWillUnmount` function is invoked

17. Recall that the commonly used component lifecycle methods include `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`


18. Use the `componentDidMount` component lifecycle method to fetch data from an API
- We will often want our component to get data from an outside source to then display to the user. This can be an API call to our own server to get database information, or to a third-party API.
- In our `componentDidMount` function, we can invoke an ajax function to get this information.
- In the following example, we're waiting for a response, then setting our state with the retrieved data, triggering a rerender of our component (allowing us to display the new content that we didn't previously have to the user)
```js
componentDidMount() {
    navigator.geolocation.getCurrentPosition(this.pollWeather);
  }

  // This functionality of getting the weather data is broken our from the componentDidMount function for clarity. It could have just as easily all been within the same function, but making this helper function makes it easier to parse what is happening.
  pollWeather = (location) => {
    let url = 'http://api.openweathermap.org/data/2.5/weather?';
    const params = {
      lat: location.coords.latitude,
      lon: location.coords.longitude
    };

    /* Remember that it's unsafe to expose your API key! In production,
    you would definitely save your key in an environment variable.
    To keep API keys simple during the development of your project,
    you can set an `apiKey` variable in this file for now. */
    const apiKey = '???';
    
    url += toQueryString(params);
    url += `&APPID=${apiKey}`;

    // We wait for our response, parse the data, then invoke setState, triggering a rerender.
    fetch(url)
      .then((res) => res.json())
      .then((weather) => this.setState({ weather }));
  }
```
