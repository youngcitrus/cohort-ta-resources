## Reading List Project

* The instructions for this project serve as a walkthrough for setting up a full-stack application. Each step is explained and example code is provided for what your files may end looking like.

* Please read through each of these instructions and code blocks and ask as many questions as you need to in order to have a solid understanding of what is going on. Don't just copy and paste the code and move on! The level of detail of this walkthrough is intentional. It can serve as a reference for future projects. 

* In addition to the topics that we've covered today/earlier this week, this project walks through some additional concepts such as:
  - Separating the application and the server. This is accomplished through creating a different entrypoint file than the `app.js` that you are used to, then requiring the app module into this file. The main takeaway from this concept is that we are separating our concerns. The new file that we are making is meant to set up our connection to the database and start our server, whereas the `app.js` file is meant to define the characteristics of the app itself, like the routes that we are establishing and error handling.
  - Debugging in VSCode. Some steps for setting up the paths for locating environment variables in a debugging environment. This is an optional configuration. Using `nodemon`'s `--inspect` is going to provide the same functionality as always, allowing you to open the debugger in the browser's devtools (I much prefer this method compared to using VSCode's built-in debugger).
  - Using Bootstrap to style components. We've seen similar concepts before, such as using the Pure css library to style tables in yesterday's project. Specific classes are used throughout the app in order to achieve a polished look without making custom css.
  - Configuring sequelize to work with an express server. We have interacted with sequelize in previous projects, but this is our first opportunity to connect our database and models to a server that we create ourselves. The configuration involves just a couple of small files:
    - `.sequelizerc`: configures sequelize-cli to tell it where to look for our config file (which gives the database, username, password, etc.), as well as the locations of the directories for models, seeders, and migrations that it generates. When we run `npx sequelize init`, the files and directories generated are based off of this file.
    - `.env`: we specify the name of our database, username, password, and host here. If we ever need to change these values, we can go to our single source of environment variables (this `.env` file) and make the necessary changes.
    - `config/index.js`: this is our module that we set up to reorganize and encapuslate our environment variables. We can add in a `db` key to collect all of our database variables under one object.
    - `config/database.js`: this is a file generated by our initialization of sequelize. In previous projects, we specified all of the variables directly here. Now we can reference the `db` object we just created. Our environment variables will cascade down to this file, which is where sequelize has been instructed to look for config variables.
  - Using `express-validator` to validate user input at the route level. Similar to how model-level validations with sequelize prevent us from having to hit our database with invalid information, these route-level validations avoid unnecessary database connections. In comparison to the sequelize validations, they can be simpler to use and provide a wide variety of pre-made checks that we can perform with our data.